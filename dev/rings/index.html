<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rings · PeriodicGraphs.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PeriodicGraphs.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../neighborhood/">Neighborhood</a></li></ul></li><li><a class="tocitem" href="../symmetries/">Symmetries</a></li><li><span class="tocitem">Algorithms</span><ul><li><a class="tocitem" href="../dimension/">Dimensionality</a></li><li class="is-active"><a class="tocitem" href>Rings</a><ul class="internal"><li><a class="tocitem" href="#Definitions"><span>Definitions</span></a></li><li><a class="tocitem" href="#Manual"><span>Manual</span></a></li><li><a class="tocitem" href="#Internal-API"><span>Internal API</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Algorithms</a></li><li class="is-active"><a href>Rings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Rings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/master/docs/src/rings.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Ring-statistics"><a class="docs-heading-anchor" href="#Ring-statistics">Ring statistics</a><a id="Ring-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Ring-statistics" title="Permalink"></a></h1><h2 id="Definitions"><a class="docs-heading-anchor" href="#Definitions">Definitions</a><a id="Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Definitions" title="Permalink"></a></h2><p>In this section, we use the terminology recommended by <a href="https://doi.org/10.1016/j.jssc.2005.06.011">Blatov, O’Keeffe and Proserpio</a>. In particular:</p><ul><li>a <em>cycle</em> is a sequence of vertices <code>v₁, v₂, ..., vₙ</code> such that for all <code>i</code> between 2 and <code>n</code>, <code>vᵢ₋₁</code> and <code>vᵢ</code> are neighbors, as well as <code>v₁</code> and <code>vₙ</code>, and no <code>vᵢ</code> occurs more than once in the sequence. It can be equivalently represented by the sequence of edges between two consecutive vertices and between <code>v₁</code> and <code>vₙ</code>.</li><li>the <em>sum</em> of two or more cycles is the set of edges occurring only an odd number of times in the set of input cycles. The sum of two cycles is thus the symmetric difference of their edges. Note that the sum of cycles may be empty, or may be the juxtaposition of several edge-disjoint cycles.</li><li>the <em>length</em> of a cycle is its number of edges. It is also equal to its number of vertices since no vertex is repeated in the sequence. A cycle <code>a</code> is strictly smaller than another <code>b</code> when the length of <code>a</code> is strictly lower than that of <code>b</code>.</li><li>a <em>ring</em> is a cycle which is not the sum of two strictly smaller cycles. An equivalent definition is that a ring is a cycle which does not admit a short-circuit: between two vertices of the ring, there is no path of the graph strictly smaller than both branches of the ring linking the two vertices.</li><li>a <em>strong ring</em> is a cycle which is not the sum of any number of strictly smaller cycles.</li></ul><h2 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h2><p><code>PeriodicGraphs.jl</code> provides an algorithm for the determination of all rings and strong rings up to a given size in a <code>PeriodicGraph</code>. It can also be used on finite graphs by converting them to <code>PeriodicGraph{0}</code>, although the code is not optimized for this case.</p><p>The <a href="#PeriodicGraphs.rings"><code>rings</code></a> (respectively <a href="#PeriodicGraphs.strong_rings"><code>strong_rings</code></a>) function returns the list of all rings (respectively strong rings) in the graph up to a given size:</p><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.rings" href="#PeriodicGraphs.rings"><code>PeriodicGraphs.rings</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rings(g::PeriodicGraph{D}, [depth::Integer=15,] symmetries::AbstractSymmetryGroup=NoSymmetryGroup(g), dist::DistanceRecord=DistanceRecord(g,depth)) where D</code></pre><p>Compute the list of rings in <code>g</code>, up to length <code>2*depth+3</code>. Return the list of <code>Vector{Int}</code> where each sublist is a ring whose vertices are the <code>reverse_hash_position</code>s of the sublist elements. Also return an <a href="../symmetries/#PeriodicGraphs.AbstractSymmetryGroup"><code>AbstractSymmetryGroup</code></a> acting on the returned rings.</p><p>A ring is a cycle of the graph for which there is no shortcut, i.e. no path in the graph between two vertices of the cycle that is shorter than either path connecting the vertices in the cycle.</p><p>If provided, <code>symmetries</code> should represent the symmetries of the graph as a <a href="../symmetries/#PeriodicGraphs.AbstractSymmetryGroup"><code>AbstractSymmetryGroup</code></a> object respecting its documented interface.</p><p>A <a href="#PeriodicGraphs.DistanceRecord"><code>PeriodicGraphs.DistanceRecord</code></a> <code>dist</code> can be optionally provided to track the distances between pairs of vertices in the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L820-L836">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.strong_rings" href="#PeriodicGraphs.strong_rings"><code>PeriodicGraphs.strong_rings</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strong_rings(g::PeriodicGraph{D}, [depth::Integer=15,] symmetries::AbstractSymmetryGroup=NoSymmetryGroup(g), dist::DistanceRecord=DistanceRecord(g,depth)) where D</code></pre><p>Compute the list of strong rings in <code>g</code>, up to length <code>2*depth+3</code>. See <a href="#PeriodicGraphs.rings"><code>rings</code></a> for the meaning of the other arguments.</p><p>A strong ring is a cycle of the graph which cannot be decomposed into a sum of any number of smaller cycles. By comparison, a ring is a cycle which cannot be decomposed into a sum of two smaller cycles. In particular, all strong rings are rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L1337-L1346">source</a></section></article><p>A few notes on the output:</p><ul><li>The output is a pair <code>(rs, symm)</code> where <code>rs</code> is the list of rings (respectively strong rings) and <code>symm</code> is an <a href="../symmetries/#PeriodicGraphs.AbstractSymmetryGroup"><code>AbstractSymmetryGroup</code></a> which contains symmetries of <code>rs</code>. <code>symm</code> is always a <a href="../symmetries/#PeriodicGraphs.NoSymmetryGroup"><code>NoSymmetryGroup</code></a> if the optional argument <code>symmetries</code> is not provided.</li><li>The returned list of rings <code>rs</code> is generally unsorted.</li><li>All translations of the same ring are represented by a unique ring, which means that a ring crossing through different unit cells will only appear once in the list, even though it may appear several times in a single unit cell.</li><li>The <code>symmetries</code> optional argument reduces the computational cost of the algorithm. The output lists <code>rs</code> with and without the optional argument are identical except for the order of their elements.</li></ul><p>The optional argument <code>depth</code> defaults to 15, which means that rings containing up to 33 edges will be considered. This default value is chosen to accomodate the vast majority of periodic nets encountered as crystal nets, for which the ring size rarely exceeds 20.</p><p>Let&#39;s take as example an aperiodic graph representing a small house, made of a cube with a pyramid on top:</p><pre><code class="language-julia-repl hljs">julia&gt; house = PeriodicGraph{0}(&quot;0 &quot;*
                    &quot;1 2  2 3  3 4  4 1 &quot;* # square base of the house
                    &quot;1 5  2 6  3 7  4 8 &quot;* # 4 vertical pillars
                    &quot;5 6  6 7  7 8  8 5 &quot;* # square ceiling
                    &quot;5 9  6 9  7 9  8 9 &quot;  # pyramidal roof
       );

julia&gt; sort!(first(rings(house)))
14-element Vector{Vector{Int64}}:
 [1, 2, 3, 4]
 [1, 2, 3, 7, 8, 5]
 [1, 2, 6, 5]
 [1, 2, 6, 7, 8, 4]
 [1, 4, 3, 7, 6, 5]
 [1, 4, 8, 5]
 [2, 3, 4, 8, 5, 6]
 [2, 3, 7, 6]
 [3, 4, 8, 7]
 [5, 6, 7, 8]
 [5, 6, 9]
 [5, 8, 9]
 [6, 7, 9]
 [7, 8, 9]

julia&gt; sort!(first(strong_rings(house)))
9-element Vector{Vector{Int64}}:
 [1, 2, 3, 4]
 [1, 2, 6, 5]
 [1, 4, 8, 5]
 [2, 3, 7, 6]
 [3, 4, 8, 7]
 [5, 6, 9]
 [5, 8, 9]
 [6, 7, 9]
 [7, 8, 9]</code></pre><p>We can see that the house has four weak rings of size 6, six rings of size 4 among which five are strong, and four strong rings of size 3.</p><p>The strong rings are the faces of the house: there are four triangles that make the roof, four squares that make the walls and one last square for the base of the house. The square corresponding to the ceiling is actually the sum of the four triangles of the roof, which is why it is not a strong ring. The four weak rings of size 6 are those that go through each vertex of the cube except for one of the four opposite pairs.</p><p>To explore the ring distributions around individual vertices, the <a href="#PeriodicGraphs.RingAttributions"><code>RingAttributions</code></a> struct factors the ring distribution by vertex. The list of rings including a particular vertex is factored into a <a href="#PeriodicGraphs.RingIncluding"><code>PeriodicGraphs.RingIncluding</code></a> struct:</p><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.RingAttributions" href="#PeriodicGraphs.RingAttributions"><code>PeriodicGraphs.RingAttributions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RingAttributions{D}</code></pre><p>Represent a set of rings of a <code>PeriodicGraph{D}</code>.</p><p>For <code>ra</code> of type <code>RingAttributions{D}</code>, <code>ra[i]</code> is a <a href="#PeriodicGraphs.RingIncluding"><code>RingIncluding{D}</code></a> object representing the set of rings including <code>PeriodicVertex{D}(i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L1356-L1363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.RingIncluding" href="#PeriodicGraphs.RingIncluding"><code>PeriodicGraphs.RingIncluding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RingIncluding{D}</code></pre><p>The list of rings of a <code>PeriodicGraph{D}</code> including a particular vertex <code>PeriodicVertex{D}(i)</code>.</p><p>The object is iterable and indexable by an integer: for <code>ri</code> of type <code>RingIncluding{D}</code>, <code>ri[j]</code> is an iterable over the vertices of the <code>j</code>-th ring including vertex <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L1416-L1424">source</a></section></article><p>To avoid useless computations, the lists of rings and the rings themselves are returned as iterables instead of <code>Vector{PeriodicVertex{N}}</code> and such, so they should be <code>collect</code>ed if required.</p><p>Let&#39;s look all the rings on our little house:</p><pre><code class="language-julia-repl hljs">julia&gt; ras = RingAttributions(house)
RingAttributions{0}(rings per node: [6, 6, 6, 6, 8, 8, 8, 8, 4])

julia&gt; roofpeak = ras[9] # 9 is the top of the roof
PeriodicGraphs.RingIncluding{0}(4 rings containing vertex 9)

julia&gt; collect(roofpeak) # the list of rings including the top of the roof
4-element Vector{PeriodicGraphs.OffsetVertexIterator{0}}:
 PeriodicVertex{0}[5, 8, 9]
 PeriodicVertex{0}[5, 6, 9]
 PeriodicVertex{0}[7, 8, 9]
 PeriodicVertex{0}[6, 7, 9]

julia&gt; collect(roofpeak[2]) # the second ring including the top of the roof
3-element Vector{PeriodicVertex{0}}:
 5
 6
 9

julia&gt; rasstrong = RingAttributions(house, true)
RingAttributions{0}(rings per node: [3, 3, 3, 3, 4, 4, 4, 4, 4])

julia&gt; collect(rasstrong[1]) # the base and two walls make the strong rings around vertex 1
3-element Vector{PeriodicGraphs.OffsetVertexIterator{0}}:
 PeriodicVertex{0}[1, 2, 6, 5]
 PeriodicVertex{0}[1, 4, 8, 5]
 PeriodicVertex{0}[1, 2, 3, 4]

julia&gt; collect(rasstrong[5]) # two rooftiles and two walls make the strong rings around vertex 5
4-element Vector{PeriodicGraphs.OffsetVertexIterator{0}}:
 PeriodicVertex{0}[5, 8, 9]
 PeriodicVertex{0}[5, 6, 9]
 PeriodicVertex{0}[1, 2, 6, 5]
 PeriodicVertex{0}[1, 4, 8, 5]</code></pre><h2 id="Internal-API"><a class="docs-heading-anchor" href="#Internal-API">Internal API</a><a id="Internal-API-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-API" title="Permalink"></a></h2><p>Here is a collection of internal utilities used for the algorithms of <a href="#PeriodicGraphs.rings"><code>rings</code></a> and <a href="#PeriodicGraphs.strong_rings"><code>strong_rings</code></a>:</p><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.ConstMiniBitSet" href="#PeriodicGraphs.ConstMiniBitSet"><code>PeriodicGraphs.ConstMiniBitSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstMiniBitSet{T} &lt;: AbstractSet{Int}</code></pre><p>Fixed-size bitset stored on a single word of type <code>T</code>, typically a <code>UInt64</code> or a <code>UInt32</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.DistanceRecord" href="#PeriodicGraphs.DistanceRecord"><code>PeriodicGraphs.DistanceRecord</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DistanceRecord{D}</code></pre><p>Record of the computed distances between vertices of a graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L276-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.JunctionNode" href="#PeriodicGraphs.JunctionNode"><code>PeriodicGraphs.JunctionNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JunctionNode{T}</code></pre><p>Element of the DAG representing the set of arcs linking each vertex <code>x</code> to a fixed vertex <code>i</code> of graph <code>g</code>. Each <code>JunctionNode</code> contains information on the arcs passing through a particular vertex <code>x</code>:</p><ul><li><code>num</code> is the length of the shortest path between <code>x</code> and <code>i</code>. Since we only collect rings, only the shortest paths are of interest, as well as the path of length <code>num+1</code> which may form an odd-length ring when combined with a shortest path.</li><li><code>heads</code> is a list of neighbors of <code>x</code> such that the <code>lastshort</code> first are at distance <code>num - 1</code> from <code>i</code>, and the rest are at distance <code>num</code> and have a lower value than <code>x</code>.</li><li><code>shortroots</code> is the set of roots reachable on a shortest path from <code>x</code> to <code>i</code>. A root is the neighbor of <code>i</code> on that path, a.k.a. the second-to-last vertex on that path.</li><li><code>longroots</code> is the set of roots reachable on a path of length <code>num+1</code> from <code>x</code> to <code>i</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L62-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.PhantomJunctionNode" href="#PeriodicGraphs.PhantomJunctionNode"><code>PeriodicGraphs.PhantomJunctionNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PhantomJunctionNode{D}</code></pre><p>Element of the phantom DAG.</p><p>Similarly to the DAG of <code>JunctionNode</code>, the phantom DAG tracks arcs linking vertices <code>x</code> to a fixed vertex <code>i</code>, except that the vertices <code>x</code> are those that should be ignored in the returned list of rings. Thus, only the shortest distance between <code>x</code> and <code>i</code> needs to be recorded, since the arcs themselves will be discarded eventually.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L97-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.arcs_list" href="#PeriodicGraphs.arcs_list"><code>PeriodicGraphs.arcs_list</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">arcs_list(g::PeriodicGraph{D}, i, depth::T, ringavoid=nothing, cycleavoid=nothing) where {D,T}</code></pre><p>Compute the list of shortest arcs starting from vertex <code>i</code> up to length <code>depth+1</code>. Vertices in <code>ringavoid</code> are not included in the returned arcs, but considered still part of the graph for distance computations. Vertices in <code>cycleavoid</code> are considered removed from the graph completely.</p><p>Return <code>(dag, vertexnums)</code> where <code>dag</code> is a <code>Vector{JunctionNode{T}}</code> representing, for each visited node, the DAG of all arcs from that node back to <code>i</code>, in a compact representation. <code>vertexnums</code> is a <code>Vector{PeriodicVertex{D}}</code> whose <code>k</code>-th value is the vertex represented by number <code>k</code> in <code>dag</code>.</p><p>If <code>ringavoid !== nothing</code>, <code>dag</code> will also not include arcs that pass through nodes of the form <code>PeriodicVertex{D}(j, ofs)</code> with <code>j == i</code> and <code>ofs &lt; zero(SVector{Int,D})</code>: this allows eagerly pruning cycles that are translations of others. Note that this can result in missing cycles if those pass through at least three nodes with <code>j == i</code>, but that situation should be exceptionally rare.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The type <code>T</code> of <code>depth</code> is used as type parameter to the <code>JunctionNode</code>, just to avoid having a dedicated argument (since <code>depth</code> should be at most 62 for the rest of the algorithm to work). This size controls the maximal degree a vertex of <code>g</code> should have : for example, <code>T == UInt32</code> indicates that all vertices must have degree at most 31.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L161-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.RingsEndingAt" href="#PeriodicGraphs.RingsEndingAt"><code>PeriodicGraphs.RingsEndingAt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RingsEndingAt(dag, midnode, record)</code></pre><p>Iterable over the rings of graph <code>g</code> around node <code>i</code> with <code>midnode</code> as vertex furthest from <code>i</code>. If there are two such vertices (odd ring), <code>midnode</code> is the higher of the two.</p><p><code>record</code> should be set to <code>(dist, vertexnums)</code> where <code>dist == DistanceRecord(g, depth)</code> and <code>dag, vertexnums == first(arcs_list(g, i, depth, ...))</code>, otherwise the iterator will return many more cycles that may not be rings.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>In order to efficiently cycle through the rings, the iterator reuses a buffer on which the rings are written. This means that performing an iteration will change the value of the previously returned result: for example, <code>collect(RingsEndingAt(...))</code> will yield a list containing the same sublist (unlikely to be an actual ring) repeated over. To actually obtain the list of rings, copy the result as they arrive by doing <code>map(copy, RingsEndingAt(...))</code> or <code>[copy(x) for x in RingsEndingAt(...)]</code> for example.</p><p>This also means that the list returned at each iteration should never be modified directly: copy it before.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L500-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.normalize_cycle!" href="#PeriodicGraphs.normalize_cycle!"><code>PeriodicGraphs.normalize_cycle!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_cycle!(cycle::Vector{Int}, n, v::Val{D}) where D</code></pre><p>In-place rotate and possibly reverse <code>cycle</code>, a <code>Vector{Int}</code> whose elements are the <code>hash_position</code> of vertices of <code>g</code> so that the result is the same for all such vectors that represent the same cycle, possibly translated to a different unit cell or rotated.</p><p>The graph <code>g::PeriodicGraph{D}</code> is represented as <code>n = nv(g)</code> and <code>v = Val(D)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L637-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.IterativeGaussianElimination" href="#PeriodicGraphs.IterativeGaussianElimination"><code>PeriodicGraphs.IterativeGaussianElimination</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IterativeGaussianElimination{T}</code></pre><p>Struct containing the list of sparse columns of the matrix under gaussian elimination on the F₂ finite field.</p><p>To be used with <a href="#PeriodicGraphs.gaussian_elimination!"><code>PeriodicGraphs.gaussian_elimination!</code></a> as one of the three concrete types:</p><ul><li><code>PeriodicGraphs.IterativeGaussianEliminationNone</code> for simple gaussian elimination,</li><li><code>PeriodicGraphs.IterativeGaussianEliminationLength</code> to detect when a new column can be expressed as a sum of strictly smaller columns of the matrix.</li><li><code>PeriodicGraphs.IterativeGaussianEliminationDecomposition</code> to detect when a new column can be expressed as a sum of other columns of the matrix and keep track of which.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L1088-L1101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.gaussian_elimination!" href="#PeriodicGraphs.gaussian_elimination!"><code>PeriodicGraphs.gaussian_elimination!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gaussian_elimination!(gauss::IterativeGaussianElimination, r::Vector{Int}) where T</code></pre><p>Test whether <code>r</code> can be expressed as a sum of vectors stored in <code>gauss</code>, and store <code>r</code> if not. &quot;sum&quot; refers to the symmetric difference of boolean vectors, represented in sparse format as the ordered list of non-zero indices.</p><p>If <code>gauss isa IterativeGaussianEliminationLength</code>, return whether <code>r</code> can be expressed as a sum of strictly smaller vectors.</p><p>Otherwise, return <code>true</code> when <code>r</code> is a sum of any previously encoutered vectors. If <code>gauss</code> isa <code>IterativeGaussianEliminationDecomposition</code>, query <code>retrieve_track(gauss)</code> to obtain the sorted list of indices of such previously encountered vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L1136-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.retrieve_track!" href="#PeriodicGraphs.retrieve_track!"><code>PeriodicGraphs.retrieve_track!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">retrieve_track!([ret::Vector{Int32}, buffer::Vector{Int32},] gauss::IterativeGaussianEliminationDecomposition)</code></pre><p>To be called consecutive to a call to <code>gaussian_elimination!(gauss, x)</code> that returned <code>true</code>. In that case, <code>x</code> was found to be the sum of previously encountered vectors: return the (reverse-sorted) list of their indices.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Calling <code>retrieve_track!</code> after a call to <code>gaussian_elimination!</code> that returned <code>false</code> will produce an invalid result. Calling it twice will also produce an invalid result.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L1214-L1225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PeriodicGraphs.rings_around" href="#PeriodicGraphs.rings_around"><code>PeriodicGraphs.rings_around</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rings_around(g::PeriodicGraph{D}, i, depth=15, dist::DistanceRecord=DistanceRecord(g,depth), visited=nothing) where D</code></pre><p>Return the list of all rings around node <code>i</code> in graph <code>g</code> up to length <code>2*depth+3</code>.</p><p>The returned rings are the list of <code>hash_position</code> of the corresponding vertices. To get back the list of actual <code>PeriodicVertex</code> of a returned <code>ring</code> in the list, do</p><pre><code class="language-julia hljs">[reverse_hash_position(x, g) for x in ring]</code></pre><p>If the offsets of the corresponding vertices are not needed, simply do</p><pre><code class="language-julia hljs">[mod1(x, n) for x in ring]   # n should be nv(g)</code></pre><p><code>visited</code> is interpreted as the <code>ringavoid</code> argument of <code>arcs_list</code> unless <code>dist === nothing</code>, in which case it is interpreted as the <code>cycleavoid</code> argument. In particular, unless <code>dist === nothing</code>, only one ring will appear in the list even if some of its translated images also pass through <code>PeriodicVertex{D}(i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Liozou/PeriodicGraphs.jl/blob/4a9bba7004793db01ba9f951e8af36af27b72230/src/algorithms/rings.jl#L692-L712">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dimension/">« Dimensionality</a><a class="docs-footer-nextpage" href="../utilities/">Utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Thursday 2 June 2022 09:50">Thursday 2 June 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
