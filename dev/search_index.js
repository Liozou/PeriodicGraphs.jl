var documenterSearchIndex = {"docs":
[{"location":"types/#Basic-types-and-definitions","page":"Types","title":"Basic types and definitions","text":"","category":"section"},{"location":"types/#Introduction","page":"Types","title":"Introduction","text":"A PeriodicGraph{N} g is the representation of an N-periodic graph.\n\nEach vertex has a unique representative, indexed from 1 to n = nv(g). Each vertex x of the graph is represented by a PeriodicVertex{N} containing both the representative v and the offset o between the unit cell containing the vertex and a reference unit cell, accessible through the syntax v, o = x, or with v = first(x) and o = last(x). The offset is a N-uplet of integers, stored as a SVector{N,Int}.\n\nEach edge e is represented by a PeriodicEdge{N} defined by its source vertex inside the reference unit cell and of representative s, and its destination vertex d, a PeriodicVertex{N}, which can be accessed through the syntax s, d = e, or with s = first(e) and d = last(e) (or d = Graphs.dst(e)).\n\nFor convenience, aliases are exported for 1D, 2D and 3D (N = 1, N = 2 and N = 3) under the names PeriodicGraph1D, PeriodicEdge2D, PeriodicVertex3D, etc.","category":"section"},{"location":"types/#PeriodicVertex","page":"Types","title":"PeriodicVertex","text":"A PeriodicVertex can be built like so:\n\njulia> PeriodicVertex1D(5, (-1,))\nPeriodicVertex1D(5, (-1,))\n\njulia> PeriodicVertex{4}(2) # shorthand for the vertices of the reference cell\nPeriodicVertex{4}(2, (0,0,0,0))","category":"section"},{"location":"types/#PeriodicEdge","page":"Types","title":"PeriodicEdge","text":"A PeriodicEdge, can be defined from src and dst or, equivalently, be the identifiers of both source and destination vertices, and the cell offset between source and destination. For example, in 3D, the edge between vertex 1 and vertex 4 in cell (0, 1, 0) is PeriodicEdge3D(1, PeriodicVertex3D(4, (0,1,0))), or, equivalently, PeriodicEdge3D(1, 4, (0,1,0)). Since PeriodicEdge(u, v, ofs) and PeriodicEdge(v, u, .-ofs) represent the same edge, one of them is called the direct edge, when it has either u < v or u == v && ofs > zero(ofs), and the other is the indirect edge. Functions isdirectedge and directedge are used for this.\n\nMore examples:\n\njulia> e = PeriodicEdge(3, PeriodicVertex(2, (0,1,0,0))) # dimensions are inferred from the input\nPeriodicEdge{4}(3, 2, (0,1,0,0))\n\njulia> isdirectedge(e)\nfalse\n\njulia> directedge(e)\nPeriodicEdge{4}(2, 3, (0,-1,0,0))\n\njulia> src, (dstv, ofs) = PeriodicEdge3D(5, 6, (1,0,2));\n\njulia> src\n5\n\njulia> dstv\n6\n\njulia> ofs\n3-element StaticArraysCore.SVector{3, Int64} with indices SOneTo(3):\n 1\n 0\n 2\n\njulia> PeriodicEdge2D(5, 5, (0,0))\nERROR: LoopException: a loop from vertex 5 to itself in the same unit cell is a forbidden edges. Maybe the offset is wrong?\n\nNote that loops (that is, edges of the form (u, u, (0,0,0,...,0))) are forbidden and will throw a PeriodicGraphs.LoopException if created. To bypass this check, use the unexported PeriodicGraphs.unsafe_edge function.","category":"section"},{"location":"types/#PeriodicGraph","page":"Types","title":"PeriodicGraph","text":"Finally, N-periodic graphs, represented by the type PeriodicGraph{N}, are defined by the number of vertices in the reference cell and the set of edges starting from the reference cell. When the number of vertices is simply the highest number appearing in the list of edges, it can be omitted. Periodic graphs can be built through several methods:\n\njulia> PeriodicGraph{5}() # create the empty graph\nPeriodicGraph{5}(0, PeriodicEdge{5}[])\n\njulia> PeriodicGraph1D(4) # create a graph with 4 vertices but no edge\nPeriodicGraph1D(4, PeriodicEdge1D[])\n\njulia> PeriodicGraph(2, PeriodicEdge{4}[(1, 1, (0,0,1,1)), (1, 1, (0,1,0,-1))]) # the dimension can be inferred\nPeriodicGraph{4}(2, PeriodicEdge{4}[(1, 1, (0,0,1,1)), (1, 1, (0,1,0,-1))])\n\njulia> PeriodicGraph3D(PeriodicEdge3D[(1, 3, (0,1,0)), (2, 2, (0,0,-1)), (1, 2, (1,0,0)), (2, 3, (0,1,1))])\nPeriodicGraph3D(3, PeriodicEdge3D[(1, 2, (1,0,0)), (1, 3, (0,1,0)), (2, 2, (0,0,1)), (2, 3, (0,1,1))])\n\njulia> parse(PeriodicGraph3D, \"3   1 2  1 0 0   1 3  0 1 0   2 2  0 0 1   2 3  0 1 1\") # compact representation of the previous graph\nPeriodicGraph3D(3, PeriodicEdge3D[(1, 2, (1,0,0)), (1, 3, (0,1,0)), (2, 2, (0,0,1)), (2, 3, (0,1,1))])\n\njulia> string(ans) # to obtain the compact representation from the graph\n\"3 1 2 1 0 0 1 3 0 1 0 2 2 0 0 1 2 3 0 1 1\"\n\njulia> string(PeriodicGraph(\"2   1 2 0 0  2 3 0 0  3 1 0 0  3 1 1 0  2 1 0 1  2 3 0 1\"))\n\"2 1 2 0 -1 1 2 0 0 1 3 -1 0 1 3 0 0 2 3 0 0 2 3 0 1\"","category":"section"},{"location":"types/#API","page":"Types","title":"API","text":"","category":"section"},{"location":"types/#Type-definitions","page":"Types","title":"Type definitions","text":"","category":"section"},{"location":"types/#Other-basic-functions","page":"Types","title":"Other basic functions","text":"","category":"section"},{"location":"types/#PeriodicGraphs.PeriodicVertex","page":"Types","title":"PeriodicGraphs.PeriodicVertex","text":"PeriodicVertex{N}\n\nVertex type for an N-periodic graph.\n\nA vertex is uniquely determined by the identifier of its representative in the a fixed initial cell, and the offset of the cell containing the vertex compared to the the initial cell. Vertex identifiers start at 1.\n\n\n\n\n\n","category":"type"},{"location":"types/#PeriodicGraphs.PeriodicEdge","page":"Types","title":"PeriodicGraphs.PeriodicEdge","text":"PeriodicEdge{N} <: Graphs.SimpleGraphs.AbstractSimpleEdge{Int}\n\nEdge type for an N-periodic graph.\n\nAn edge is uniquely determined by the vertex identifiers of its source and destination, and the cell offset between the source vertex and the destination vertex.\n\n\n\n\n\n","category":"type"},{"location":"types/#PeriodicGraphs.PeriodicGraph","page":"Types","title":"PeriodicGraphs.PeriodicGraph","text":"PeriodicGraph{N} <: AbstractGraph{Int}\n\nType representing an undirected N-periodic graph.\n\n\n\n\n\n","category":"type"},{"location":"types/#PeriodicGraphs.PeriodicGraph-Union{Tuple{}, Tuple{Integer}, Tuple{N}} where N","page":"Types","title":"PeriodicGraphs.PeriodicGraph","text":"PeriodicGraph{N}(nv::Integer=0)\n\nConstruct a PeriodicGraph{N} with nv vertices and 0 edge.\n\n\n\n\n\n","category":"method"},{"location":"types/#PeriodicGraphs.PeriodicGraph-Union{Tuple{N}, Tuple{Integer, AbstractArray{PeriodicEdge{N}, 1}}} where N","page":"Types","title":"PeriodicGraphs.PeriodicGraph","text":"PeriodicGraph([nv::Integer, ]edge_list::AbstractVector{PeriodicEdge{N}})\nPeriodicGraph{N}([nv::Integer, ]edge_list::AbstractVector{PeriodicEdge{N}})\n\nConstruct a PeriodicGraph{N} from a vector of edges. If nv is unspecified, the number of vertices is the highest that is used in an edge in edge_list.\n\nImplementation Notes\n\nThis constructor works the fastest when edge_list is sorted by the lexical ordering and does not contain any duplicates.\n\nExamples\n\njulia> el = PeriodicEdge2D[(1, 1, (1,0)), (1, 3, (0,1)), (3, 1, (0,-1))];\n\njulia> g = PeriodicGraph(el)\nPeriodicGraph2D(3, PeriodicEdge2D[(1, 1, (1,0)), (1, 3, (0,1))])\n\njulia> ne(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"types/#PeriodicGraphs.PeriodicGraph-Union{Tuple{AbstractString}, Tuple{N}} where N","page":"Types","title":"PeriodicGraphs.PeriodicGraph","text":"PeriodicGraph(key::AbstractString)\nPeriodicGraph{N}(key::AbstractString)\n\nConstruct a PeriodicGraph{N} from a key, which is a string of whitespace-separated values of the form \"N src1 dst1 ofs1_1 ofs1_2 ... ofs1_N src2 dst2 ofs2_1 ofs2_2 ... ofs2_N  ...  srcm dstm ofsm_1 ofsm_2 ... ofsm_N\" where N is the number of repeating dimensions of the graph, m is the number of edges and for all i between 1 and m, the number of edges, the i-th edge is described as\n\nsrci, the vertex identifier of the source vertex,\ndsti, the vertex identifier of the destination vertex and\n(ofsi_1, ofsi_2, ..., ofsi_N) the offset of the edge.\n\nThis compact representation of a graph can be obtained simply by printing the graph or with string.\n\nnote: Note\nUse parse(PeriodicGraph, key) or parse(PeriodicGraph{N}, key) for a faster implementation if key was obtained from string(g) with g a PeriodicGraph{N}.\n\nExamples\n\njulia> PeriodicGraph(\"2  1 2 0 0  2 1 1 0  1 1 0 -1\")\nPeriodicGraph2D(2, PeriodicEdge2D[(1, 1, (0,1)), (1, 2, (-1,0)), (1, 2, (0,0))])\n\njulia> PeriodicGraph3D(\"3  1 1 0 0 1  1 1 0 1 0  1 1 1 0 0\")\nPeriodicGraph3D(1, PeriodicEdge3D[(1, 1, (0,0,1)), (1, 1, (0,1,0)), (1, 1, (1,0,0))])\n\njulia> string(ans)\n\"3 1 1 0 0 1 1 1 0 1 0 1 1 1 0 0\"\n\njulia> string(parse(PeriodicGraph3D, ans)) == ans\ntrue\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.parse-Union{Tuple{N}, Tuple{Type{PeriodicGraph{N}}, AbstractString}} where N","page":"Types","title":"Base.parse","text":"parse(::Type{PeriodicGraph}, key::AbstractString)\nparse(::Type{PeriodicGraph{N}}, key::AbstractString)\n\nParse a string representation of a PeriodicGraph back to a PeriodicGraph.\n\nSee PeriodicGraph(key::AbstractString) or PeriodicGraph{N}(key::AbstractString) for details on the string representations of a PeriodicGraph.\n\nwarning: Warning\nThis function assumes that the string is a valid representation of a PeriodicGraph with all its edges direct, sorted in lexicographical order and unique, as obtained from string(g) or print(g) where g is a PeriodicGraph. No check is performed to ensure this condition.If the input string may not obey these conditions, use PeriodicGraph(key) or PeriodicGraph{N}(key) instead.\n\n\n\n\n\n","category":"method"},{"location":"types/#PeriodicGraphs.isdirectedge","page":"Types","title":"PeriodicGraphs.isdirectedge","text":"isdirectedge(e::PeriodicEdge)\n\nReturn true if e is direct, in the sense being of the form (u, v, ofs) with either u < v or u == v && ofs > zero(ofs).\n\nAn edge e is indirect iff reverse(e) is not.\n\nExamples\n\njulia> isdirectedge(PeriodicEdge1D(3, 4, (0,)))\ntrue\n\njulia> isdirectedge(PeriodicEdge2D(5, 2, (0,0)))\nfalse\n\njulia> isdirectedge(PeriodicEdge3D(3, 3, (0,-1,2)))\nfalse\n\nSee also directedge\n\n\n\n\n\n","category":"function"},{"location":"types/#PeriodicGraphs.directedge","page":"Types","title":"PeriodicGraphs.directedge","text":"directedge(e::PeriodicEdge{D}) where D\ndirectedge(src::PeriodicVertex{D}, dst::PeriodicVertex{D}) where D\ndirectedge(src, dst, ofs::Union{SVector{D,T},NTuple{D,T}}) where {D,T}\n\nReturn the direct edge corresponding to e = PeriodicEdge{D}(src, dst), i.e. e itself if e is direct, or reverse(e) otherwise.\n\nExamples\n\njulia> directedge(PeriodicEdge1D(3, 4, (0,)))\nPeriodicEdge1D(3, 4, (0,))\n\njulia> directedge(PeriodicEdge2D(5, 2, (0,0)))\nPeriodicEdge2D(2, 5, (0,0))\n\njulia> directedge(PeriodicEdge3D(3, 3, (0,-1,2)))\nPeriodicEdge3D(3, 3, (0,1,-2))\n\nSee also isdirectedge\n\n\n\n\n\n","category":"function"},{"location":"types/#PeriodicGraphs.unsafe_edge","page":"Types","title":"PeriodicGraphs.unsafe_edge","text":"unsafe_edge{N}\n\nInternal constructor for PeriodicEdge{N} that bypasses the loop check.\n\n\n\n\n\n","category":"type"},{"location":"types/#PeriodicGraphs.LoopException","page":"Types","title":"PeriodicGraphs.LoopException","text":"LoopException <: Exception\n\nError type for constructing an invalid PeriodicEdge{N} of the form (u, u, zeros(Int,N)). Loops are not expected in the algorithms implemented in PeriodicGraphs.jl. If you still want to construct them, use the unsafe_edge{N} constructor instead of PeriodicEdge{N}.\n\n\n\n\n\n","category":"type"},{"location":"neighborhood/#Neighborhoods-and-graph-traversals","page":"Neighborhood","title":"Neighborhoods and graph traversals","text":"","category":"section"},{"location":"neighborhood/#Manual","page":"Neighborhood","title":"Manual","text":"The AbstractGraph API for exploring neighbors and traversing graphs has to be somewhat adapted to account for the specific aspects of PeriodicGraphs. Here, we present a list of notes relative to these aspects, where g is a PeriodicGraph{N}:\n\nneighbors(g, i) where i::Integer is the list of neighbors of PeriodicVertex{N}(i). Performance-wise, this operation is a simple access on the underlying structure of g so it is very fast, but the returned Vector{PeriodicVertex{N}} should not be modified.\nneighbors(g, x) where x::PeriodicVertex{N} is an iterator over the neighbors of x but not an array. The iterator object is a PeriodicGraphs.OffsetVertexIterator.\nedges(g) is an iterator over the direct edges of g. Every edge representative will thus be visited exactly once. It is invalidated by any change to g, so g should not be modified while iterating over edges(g). The iterator object is a PeriodicGraphs.PeriodicEdgeIter.\nGraphs._neighborhood has a specialization for PeriodicGraph if required.\n\nA typical BFS algorithm on g can be implemented like so:\n\nfunction bfs(g::PeriodicGraph{N}, starting_vertex, depth) where N\n    visited = Set{PeriodicVertex{N}}(starting_vertex)\n    Q = Tuple{Int,PeriodicVertex{N}}[(0, starting_vertex)]\n    for (distance, u) in Q\n        distance > depth && break\n        # do stuff with u\n        for x in neighbors(g, u)\n            x âˆˆ visited && continue\n            push!(x, visited)\n            # do stuff with x\n            push!(Q, (distance+1, x))\n        end\n        # do more stuff\n    end\n    # return something\nend\n\nIn some cases however, the Set-interface can end up being the bottleneck. In this kind of situation, it may be better to:\n\nreplace the initialization of visited by\nwidth = PeriodicGraphs.graph_width!(g)\nseen_size = nv(g)*(2*(1 + fld(depth-1, width)) + 1)^N\nvisited = falses(seen_size)\nreplace x âˆˆ visited by visited[hash_position(x, g)] and\nreplace push!(x, visited) by visited[hash_position(x, g)] = true\n\nalthough some care should be taken since PeriodicGraphs.graph_width! is only a heuristic.\n\nSuch algorithms can be used to compute the topological invariants like coordination_sequence for example.","category":"section"},{"location":"neighborhood/#API","page":"Neighborhood","title":"API","text":"","category":"section"},{"location":"neighborhood/#PeriodicGraphs.PeriodicEdgeIter","page":"Neighborhood","title":"PeriodicGraphs.PeriodicEdgeIter","text":"PeriodicEdgeIter{N} <: AbstractEdgeIter\n\nEdge iterator type for undirected N-periodic graphs.\n\nThe iterator only yields edges in the form (u, v, ofs) with either u < v or u == v && ofs > zero(ofs). This is possible because PeriodicGraphs are undirected, hence to each edge (u, v, ofs) in the graph corresponds its reverse edge (v, u, .-ofs). The iterator thus yields each edge of the graph exactly once.\n\n\n\n\n\n","category":"type"},{"location":"neighborhood/#PeriodicGraphs.OffsetVertexIterator","page":"Neighborhood","title":"PeriodicGraphs.OffsetVertexIterator","text":"OffsetVertexIterator{D} <: AbstractVector{PeriodicVertex{D}}\nOffsetVertexIterator(ofs::SVector{D,Int}, list::AbstractVector{PeriodicVertex{D}}) where D\n\nIterator type that yields the sequence of PeriodicVertex in list, each offset by the input ofs.\n\n\n\n\n\n","category":"type"},{"location":"neighborhood/#PeriodicGraphs.graph_width!","page":"Neighborhood","title":"PeriodicGraphs.graph_width!","text":"graph_width!(g::PeriodicGraph{N}) where N\n\nSet the width internal field of the graph so that the for most n âˆˆ N*, the n-th neighbor of any vertex v of the initial cell is in a cell (i_1, i_2, ..., i_N) such that max(abs.((i_1, i_2, ..., i_N))) â‰¤ 1 + fld((n - 1), width). Return the new width.\n\nThis function is only a heuristic, it may produce a width that does not satisfy the condition.\n\nThis function returns the current width if it is not equal to -1 (internal value used to mark an unset width). If you decide to modify the other internal fields of g, it is probably a good idea to do g.width[] = -1 so that this function gets automatically called when needed, unless you are sure the width will not be affected by your change.\n\n\n\n\n\n","category":"function"},{"location":"rings/#Ring-statistics","page":"Rings","title":"Ring statistics","text":"","category":"section"},{"location":"rings/#Definitions","page":"Rings","title":"Definitions","text":"In this section, we use the terminology recommended by Blatov, Oâ€™Keeffe and Proserpio. In particular:\n\na cycle is a sequence of vertices vâ‚, vâ‚‚, ..., vâ‚™ such that for all i between 2 and n, váµ¢â‚‹â‚ and váµ¢ are neighbors, as well as vâ‚ and vâ‚™, and no váµ¢ occurs more than once in the sequence. It can be equivalently represented by the sequence of edges between two consecutive vertices and between vâ‚ and vâ‚™.\nthe sum of two or more cycles is the set of edges occurring only an odd number of times in the set of input cycles. The sum of two cycles is thus the symmetric difference of their edges. Note that the sum of cycles may be empty, or may be the juxtaposition of several edge-disjoint cycles.\nthe length of a cycle is its number of edges. It is also equal to its number of vertices since no vertex is repeated in the sequence. A cycle a is strictly smaller than another b when the length of a is strictly lower than that of b.\na ring is a cycle which is not the sum of two strictly smaller cycles. An equivalent definition is that a ring is a cycle which does not admit a short-circuit: between two vertices of the ring, there is no path of the graph strictly smaller than both branches of the ring linking the two vertices.\na strong ring is a cycle which is not the sum of any number of strictly smaller cycles.","category":"section"},{"location":"rings/#Manual","page":"Rings","title":"Manual","text":"PeriodicGraphs.jl provides an algorithm for the determination of all rings and strong rings up to a given size in a PeriodicGraph. It can also be used on finite graphs by converting them to PeriodicGraph{0}, although the code is not optimized for this case.\n\nThe rings (respectively strong_rings) function returns the list of all rings (respectively strong rings) in the graph up to a given size:\n\nA few notes on the output:\n\nThe output is a pair (rs, symm) where rs is the list of rings (respectively strong rings) and symm is an AbstractSymmetryGroup which contains symmetries of rs. symm is always a NoSymmetryGroup if the optional argument symmetries is not provided.\nThe returned list of rings rs is generally unsorted.\nAll translations of the same ring are represented by a unique ring, which means that a ring crossing through different unit cells will only appear once in the list, even though it may appear several times in a single unit cell.\nThe symmetries optional argument reduces the computational cost of the algorithm. The output lists rs with and without the optional argument are identical except for the order of their elements.\n\nThe optional argument depth defaults to 15, which means that rings containing up to 33 edges will be considered. This default value is chosen to accomodate the vast majority of periodic nets encountered as crystal nets, for which the ring size rarely exceeds 20.\n\nLet's take as example an aperiodic graph representing a small house, made of a cube with a pyramid on top:\n\njulia> house = PeriodicGraph{0}(\"0 \"*\n                    \"1 2  2 3  3 4  4 1 \"* # square base of the house\n                    \"1 5  2 6  3 7  4 8 \"* # 4 vertical pillars\n                    \"5 6  6 7  7 8  8 5 \"* # square ceiling\n                    \"5 9  6 9  7 9  8 9 \"  # pyramidal roof\n       );\n\njulia> sort!(first(rings(house)))\n14-element Vector{Vector{Int64}}:\n [1, 2, 3, 4]\n [1, 2, 3, 7, 8, 5]\n [1, 2, 6, 5]\n [1, 2, 6, 7, 8, 4]\n [1, 4, 3, 7, 6, 5]\n [1, 4, 8, 5]\n [2, 3, 4, 8, 5, 6]\n [2, 3, 7, 6]\n [3, 4, 8, 7]\n [5, 6, 7, 8]\n [5, 6, 9]\n [5, 8, 9]\n [6, 7, 9]\n [7, 8, 9]\n\njulia> sort!(first(strong_rings(house)))\n9-element Vector{Vector{Int64}}:\n [1, 2, 3, 4]\n [1, 2, 6, 5]\n [1, 4, 8, 5]\n [2, 3, 7, 6]\n [3, 4, 8, 7]\n [5, 6, 9]\n [5, 8, 9]\n [6, 7, 9]\n [7, 8, 9]\n\nWe can see that the house has four weak rings of size 6, six rings of size 4 among which five are strong, and four strong rings of size 3.\n\nThe strong rings are the faces of the house: there are four triangles that make the roof, four squares that make the walls and one last square for the base of the house. The square corresponding to the ceiling is actually the sum of the four triangles of the roof, which is why it is not a strong ring. The four weak rings of size 6 are those that go through each vertex of the cube except for one of the four opposite pairs.\n\nTo explore the ring distributions around individual vertices, the RingAttributions struct factors the ring distribution by vertex. The list of rings including a particular vertex is factored into a RingIncluding struct:\n\nTo avoid useless computations, the lists of rings and the rings themselves are returned as iterables instead of Vector{PeriodicVertex{N}} and such, so they should be collected if required.\n\nLet's look all the rings on our little house:\n\njulia> ras = RingAttributions(house)\nRingAttributions{0}(rings per node: [6, 6, 6, 6, 8, 8, 8, 8, 4])\n\njulia> roofpeak = ras[9] # the list of rings including the top of the roof\n4-element RingIncluding{0}:\n [5, 8, 9]\n [5, 6, 9]\n [7, 8, 9]\n [6, 7, 9]\n\njulia> roofpeak[2] # the second ring including the top of the roof\n3-element PeriodicGraphs.OffsetVertexIterator{0}:\n 5\n 6\n 9\n\njulia> rasstrong = RingAttributions(house, true)\nRingAttributions{0}(rings per node: [3, 3, 3, 3, 4, 4, 4, 4, 4])\n\njulia> rasstrong[1] # the base and two walls make the strong rings around vertex 1\n3-element RingIncluding{0}:\n [1, 2, 6, 5]\n [1, 4, 8, 5]\n [1, 2, 3, 4]\n\njulia> collect(rasstrong[5]) # two rooftiles and two walls make the strong rings around vertex 5\n4-element Vector{PeriodicGraphs.OffsetVertexIterator{0}}:\n [5, 8, 9]\n [5, 6, 9]\n [1, 2, 6, 5]\n [1, 4, 8, 5]","category":"section"},{"location":"rings/#Internal-API","page":"Rings","title":"Internal API","text":"Here is a collection of internal utilities used for the algorithms of rings and strong_rings:","category":"section"},{"location":"rings/#PeriodicGraphs.rings","page":"Rings","title":"PeriodicGraphs.rings","text":"rings(g::PeriodicGraph{D}, [depth::Integer=15,] symmetries::AbstractSymmetryGroup=NoSymmetryGroup(g), dist::DistanceRecord=DistanceRecord(g,depth)) where D\n\nCompute the list of rings in g, up to length 2*depth+3. Return the list of Vector{Int} where each sublist is a ring whose vertices are the reverse_hash_positions of the sublist elements. Also return an AbstractSymmetryGroup acting on the returned rings.\n\nA ring is a cycle of the graph for which there is no shortcut, i.e. no path in the graph between two vertices of the cycle that is shorter than either path connecting the vertices in the cycle.\n\nIf provided, symmetries should represent the symmetries of the graph as a AbstractSymmetryGroup object respecting its documented interface.\n\nA PeriodicGraphs.DistanceRecord dist can be optionally provided to track the distances between pairs of vertices in the graph.\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.strong_rings","page":"Rings","title":"PeriodicGraphs.strong_rings","text":"strong_rings([rs::Vector{Vector{Int}},] g::PeriodicGraph{D}, [depth::Integer=15,] symmetries::AbstractSymmetryGroup=NoSymmetryGroup(g), dist::DistanceRecord=DistanceRecord(g,depth)) where D\n\nCompute the list of strong rings in g, up to length 2*depth+3. Return them with their symmetry group. Each ring is represented by the list of hash_position of its vertices.\n\nThe optional first argument rs is the list of rings which can be provided if previously computed.\n\nSee rings for the meaning of the other arguments.\n\nA strong ring is a cycle of the graph which cannot be decomposed into a sum of any number of smaller cycles. By comparison, a ring is a cycle which cannot be decomposed into a sum of two smaller cycles. In particular, all strong rings are rings.\n\nSee also strong_erings to obtain the rings as a list of integers representing the edges of the ring, instead of a list of integers representing its vertices.\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.RingAttributions","page":"Rings","title":"PeriodicGraphs.RingAttributions","text":"RingAttributions{D} <: AbstractVector{RingIncluding{D}}\n\nRepresent a set of rings of a PeriodicGraph{D}.\n\nFor ra of type RingAttributions{D}, ra[i] is a RingIncluding{D} object representing the set of rings including PeriodicVertex{D}(i).\n\n\n\n\n\n","category":"type"},{"location":"rings/#PeriodicGraphs.RingIncluding","page":"Rings","title":"PeriodicGraphs.RingIncluding","text":"RingIncluding{D} <: AbstractVector{OffsetVertexIterator{D}}\n\nThe list of rings of a PeriodicGraph{D} including a particular vertex PeriodicVertex{D}(i).\n\nThe object is iterable and indexable by an integer: for ri of type RingIncluding{D}, ri[j] is an iterable over the vertices of the j-th ring including vertex i.\n\n\n\n\n\n","category":"type"},{"location":"rings/#PeriodicGraphs.ConstMiniBitSet","page":"Rings","title":"PeriodicGraphs.ConstMiniBitSet","text":"ConstMiniBitSet{T} <: AbstractSet{Int}\n\nFixed-size bitset stored on a single word of type T, typically a UInt64 or a UInt32.\n\n\n\n\n\n","category":"type"},{"location":"rings/#PeriodicGraphs.DistanceRecord","page":"Rings","title":"PeriodicGraphs.DistanceRecord","text":"DistanceRecord{D}\n\nRecord of the computed distances between vertices of a graph.\n\n\n\n\n\n","category":"type"},{"location":"rings/#PeriodicGraphs.JunctionNode","page":"Rings","title":"PeriodicGraphs.JunctionNode","text":"JunctionNode{T}\n\nElement of the DAG representing the set of arcs linking each vertex x to a fixed vertex i of graph g. Each JunctionNode contains information on the arcs passing through a particular vertex x:\n\nnum is the length of the shortest path between x and i. Since we only collect rings, only the shortest paths are of interest, as well as the path of length num+1 which may form an odd-length ring when combined with a shortest path.\nheads is a list of neighbors of x such that the lastshort first are at distance num - 1 from i, and the rest are at distance num and have a lower value than x.\nshortroots is the set of roots reachable on a shortest path from x to i. A root is the neighbor of i on that path, a.k.a. the second-to-last vertex on that path.\nlongroots is the set of roots reachable on a path of length num+1 from x to i.\n\n\n\n\n\n","category":"type"},{"location":"rings/#PeriodicGraphs.PhantomJunctionNode","page":"Rings","title":"PeriodicGraphs.PhantomJunctionNode","text":"PhantomJunctionNode{D}\n\nElement of the phantom DAG.\n\nSimilarly to the DAG of JunctionNode, the phantom DAG tracks arcs linking vertices x to a fixed vertex i, except that the vertices x are those that should be ignored in the returned list of rings. Thus, only the shortest distance between x and i needs to be recorded, since the arcs themselves will be discarded eventually.\n\n\n\n\n\n","category":"type"},{"location":"rings/#PeriodicGraphs.arcs_list","page":"Rings","title":"PeriodicGraphs.arcs_list","text":"arcs_list(g::PeriodicGraph{D}, i, depth::T, ringavoid=nothing, cycleavoid=nothing) where {D,T}\n\nCompute the list of shortest arcs starting from vertex i up to length depth+1. Vertices in ringavoid are not included in the returned arcs, but considered still part of the graph for distance computations. Vertices in cycleavoid are considered removed from the graph completely.\n\nReturn (dag, vertexnums) where dag is a Vector{JunctionNode{T}} representing, for each visited node, the DAG of all arcs from that node back to i, in a compact representation. vertexnums is a Vector{PeriodicVertex{D}} whose k-th value is the vertex represented by number k in dag.\n\nIf ringavoid !== nothing, dag will also not include arcs that pass through nodes of the form PeriodicVertex{D}(j, ofs) with j == i and ofs < zero(SVector{Int,D}): this allows eagerly pruning cycles that are translations of others. Note that this can result in missing cycles if those pass through at least three nodes with j == i, but that situation should be exceptionally rare.\n\nnote: Note\nThe type T of depth is used as type parameter to the JunctionNode, just to avoid having a dedicated argument (since depth should be at most 62 for the rest of the algorithm to work). This size controls the maximal degree a vertex of g should have : for example, T == UInt32 indicates that all vertices must have degree at most 31.\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.RingsEndingAt","page":"Rings","title":"PeriodicGraphs.RingsEndingAt","text":"RingsEndingAt(dag, midnode, record)\n\nIterable over the rings of graph g around node i with midnode as vertex furthest from i. If there are two such vertices (odd ring), midnode is the higher of the two.\n\nrecord should be set to (dist, vertexnums) where dist == DistanceRecord(g, depth) and dag, vertexnums == first(arcs_list(g, i, depth, ...)), otherwise the iterator will return many more cycles that may not be rings.\n\nwarning: Warning\nIn order to efficiently cycle through the rings, the iterator reuses a buffer on which the rings are written. This means that performing an iteration will change the value of the previously returned result: for example, collect(RingsEndingAt(...)) will yield a list containing the same sublist (unlikely to be an actual ring) repeated over. To actually obtain the list of rings, copy the result as they arrive by doing map(copy, RingsEndingAt(...)) or [copy(x) for x in RingsEndingAt(...)] for example.This also means that the list returned at each iteration should never be modified directly: copy it before.\n\n\n\n\n\n","category":"type"},{"location":"rings/#PeriodicGraphs.normalize_cycle!","page":"Rings","title":"PeriodicGraphs.normalize_cycle!","text":"normalize_cycle!(cycle::Vector{Int}, n, v::Val{D}) where D\n\nIn-place rotate and possibly reverse cycle, a Vector{Int} whose elements are the hash_position of vertices of g so that the result is the same for all such vectors that represent the same cycle, possibly translated to a different unit cell or rotated.\n\nThe graph g::PeriodicGraph{D} is represented as n = nv(g) and v = Val(D)\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.symdiff_cycles!","page":"Rings","title":"PeriodicGraphs.symdiff_cycles!","text":"symdiff_cycles!(c::Vector{T}, a::Vector{T}, b::Vector{T}) where T\n\nLike PeriodicGraphs.symdiff_cycles but stores the result in c.\n\nc will be resized accordingly so its initial length does not matter.\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.symdiff_cycles","page":"Rings","title":"PeriodicGraphs.symdiff_cycles","text":"symdiff_cycles(a, b)\n\nSymmetric difference between two sorted lists a and b. Return the sorted list of elements belonging to a or to b but not to both.\n\nUse PeriodicGraphs.symdiff_cycles! to provide a pre-allocated destination.\n\nExample\n\njulia> PeriodicGraphs.symdiff_cycles([3,4,5], [4,5,6])\n2-element Vector{Int64}:\n 3\n 6\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.IterativeGaussianElimination","page":"Rings","title":"PeriodicGraphs.IterativeGaussianElimination","text":"IterativeGaussianElimination{T}\n\nStruct containing the list of sparse columns of the matrix under gaussian elimination on the ð”½â‚‚ finite field.\n\nTo be used with PeriodicGraphs.gaussian_elimination! as one of the three concrete types:\n\nPeriodicGraphs.IterativeGaussianEliminationNone for simple gaussian elimination,\nPeriodicGraphs.IterativeGaussianEliminationLength to detect when a new column can be expressed as a sum of strictly smaller columns of the matrix.\nPeriodicGraphs.IterativeGaussianEliminationDecomposition to detect when a new column can be expressed as a sum of other columns of the matrix and keep track of which.\n\n\n\n\n\n","category":"type"},{"location":"rings/#PeriodicGraphs.gaussian_elimination!","page":"Rings","title":"PeriodicGraphs.gaussian_elimination!","text":"gaussian_elimination!(gauss::IterativeGaussianElimination, r::Vector{Int})\n\nTest whether r can be expressed as a sum of vectors stored in gauss, and store r if not. \"sum\" refers to the symmetric difference of boolean vectors, represented in sparse format as the ordered list of non-zero indices.\n\nIf gauss isa IterativeGaussianEliminationLength, return whether r can be expressed as a sum of strictly smaller vectors.\n\nOtherwise, return true when r is a sum of any previously encoutered vectors. If gauss isa IterativeGaussianEliminationDecomposition, query retrieve_track(gauss) to obtain the sorted list of indices of such previously encountered vectors.\n\nSee also gaussian_elimination to test r without storing it.\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.gaussian_elimination","page":"Rings","title":"PeriodicGraphs.gaussian_elimination","text":"gaussian_elimination(gauss::IterativeGaussianElimination, r::Vector{Int})\n\nReturn notindependent, info where notindependent is true if r can be expressed as a sum of vectors stored in gauss.\n\nSee PeriodicGraphs.gaussian_elimination! to store r in gauss if not, and for more details dependending on the type of gauss.\n\nCall PeriodicGraphs.gaussian_elimination!(gauss, r, notindependent, info) to obtain the result of PeriodicGraphs.gaussian_elimination!(gauss, r) without duplicating computation.\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.intersect_cycles!","page":"Rings","title":"PeriodicGraphs.intersect_cycles!","text":"intersect_cycles!(c::Vector{T}, a::Vector{T}, b::Vector{T}) where T\n\nLike PeriodicGraphs.intersect_cycles but stores the result in c.\n\nc will be resized accordingly so its initial length does not matter as long as it is at least as large as the resulting list.\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.intersect_cycles","page":"Rings","title":"PeriodicGraphs.intersect_cycles","text":"intersect_cycles(a, b)\n\nIntersection between two sorted lists a and b. Return the sorted list of elements belonging to both a and b.\n\nUse PeriodicGraphs.intersect_cycles! to provide a pre-allocated destination.\n\nExample\n\njulia> PeriodicGraphs.intersect_cycles([3,4,5], [4,5,6])\n2-element Vector{Int64}:\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.union_cycles!","page":"Rings","title":"PeriodicGraphs.union_cycles!","text":"union_cycles!(c::Vector{T}, a::Vector{T}, b::Vector{T}) where T\n\nLike PeriodicGraphs.union_cycles but stores the result in c.\n\nc will be resized accordingly so its initial length does not matter as long as it is at least as large as the resulting list.\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.union_cycles","page":"Rings","title":"PeriodicGraphs.union_cycles","text":"union_cycles(a, b)\n\nUnion between two sorted lists a and b. Return the sorted list of elements belonging to a or b or both.\n\nUse PeriodicGraphs.union_cycles! to provide a pre-allocated destination.\n\nExample\n\njulia> PeriodicGraphs.union_cycles([3,4,5], [4,5,6])\n4-element Vector{Int64}:\n 3\n 4\n 5\n 6\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.retrieve_track!","page":"Rings","title":"PeriodicGraphs.retrieve_track!","text":"retrieve_track!([ret::Vector{Int32}, buffer::Vector{Int32},] gauss::IterativeGaussianEliminationDecomposition)\n\nTo be called consecutive to a call to gaussian_elimination!(gauss, x) that returned true. In that case, x was found to be the sum of previously encountered vectors: return the (reverse-sorted) list of their indices.\n\nwarning: Warning\nCalling retrieve_track! after a call to gaussian_elimination! that returned false will produce an invalid result. Calling it twice will also produce an invalid result.\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.rings_around","page":"Rings","title":"PeriodicGraphs.rings_around","text":"rings_around(g::PeriodicGraph{D}, i, depth=15, dist::DistanceRecord=DistanceRecord(g,depth), visited=nothing) where D\n\nReturn the list of all rings around node i in graph g up to length 2*depth+3.\n\nThe returned rings are the list of hash_position of the corresponding vertices. To get back the list of actual PeriodicVertex of a returned ring in the list, do\n\n[reverse_hash_position(x, g) for x in ring]\n\nIf the offsets of the corresponding vertices are not needed, simply do\n\n[mod1(x, n) for x in ring]   # n should be nv(g)\n\nvisited is interpreted as the ringavoid argument of arcs_list unless dist === nothing, in which case it is interpreted as the cycleavoid argument. In particular, unless dist === nothing, only one ring will appear in the list even if some of its translated images also pass through PeriodicVertex{D}(i).\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.EdgeDict","page":"Rings","title":"PeriodicGraphs.EdgeDict","text":"EdgeDict{D}\n\nMap from pairs of PeriodicVertex{D} to the identifier of the corresponding edge.\n\nkp::EdgeDict{D} should be queried by either get!(kp, minmax(v1, v2)) where v1 and v2 are PeriodicVertex{D} to obtain the identifier of the edge and store a new identifier if absent, or by kp[i] where i is an Integer to obtain the pair of vertices corresponding to identifier i.\n\nkp is built by calling EdgeDict(g) where g is a PeriodicGraph.\n\n\n\n\n\n","category":"type"},{"location":"rings/#PeriodicGraphs.strong_erings","page":"Rings","title":"PeriodicGraphs.strong_erings","text":"strong_erings([rs::Vector{Vector{Int}},], g::PeriodicGraph{D}, [depth=15,] ringsymms::AbstractSymmetryGroup=NoSymmetryGroup(length(rs))) where D\n\nCompute the list of strong edge rings in g, up to length 2*depth+3. See strong_rings and rings for the meaning of the optional arguments.\n\nReturn a quadruplet of values:\n\nthe two first values are the list of rings and their symmetry group, identical to the result of strong_rings, unless rs is provided (see below).\nthe third is the list of edge rings: each edge of the periodic graph is mapped to an integer and each ring is represented by the sorted list of its edges.\nthe last is the mapping from edges to integers, given as an EdgeDict.\n\nIf rs is provided, the first returned value is the list of indices keep of rs such that rs[keep] is the list of strong rings.\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.convert_to_ering!","page":"Rings","title":"PeriodicGraphs.convert_to_ering!","text":"convert_to_ering!(buffer::Vector{Int}, ring::Vector{PeriodicVertex{D}}, kp::EdgeDict{D}, ofs, len) where D\n\nReturn the edge ring corresponding to OffsetVertexIterator{D}(ring[1:len], ofs) inside buffer, resized to length len.\n\nSee also PeriodicGraphs.convert_to_ering.\n\n\n\n\n\n","category":"function"},{"location":"rings/#PeriodicGraphs.convert_to_ering","page":"Rings","title":"PeriodicGraphs.convert_to_ering","text":"convert_to_ering(ring::Vector{PeriodicVertex{D}}, kp::EdgeDict{D}, ofs=zero(SVector{D,Int}), len=length(ring)) where D\n\nReturn the edge ring corresponding to OffsetVertexIterator{D}(ring[1:len], ofs).\n\nSee also PeriodicGraphs.convert_to_ering! to provide a buffer.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/#Hashing","page":"Utilities","title":"Hashing","text":"It is sometimes convenient to be able to associate to each vertex of periodic graph g an integer hash, such that the hashes of vertices in the reference unit cell are between 1 and nv(g), the hashes of the vertices in the unit cells around the reference are next, then the vertices of the unit cells around those, etc. To do so, PeriodicGraphs.jl export the hash_position function as follows:\n\nThe reciproque function is also exported:\n\nBoth functions are optimized for dimensions 1, 2 and 3, especially for unit cells not too far from the reference.","category":"section"},{"location":"utilities/#Isomorphic-transformations","page":"Utilities","title":"Isomorphic transformations","text":"Several functions transform a periodic graph into another isomorphic to the input, by renumbering the vertices (vertex_permutation) or the axes (swap_axes!), or by offsetting the chosen representatives for each vertex (offset_representatives!). It is also possible to make an isomorphic graph with more vertices per unit cell by using a supercell (make_supercell).","category":"section"},{"location":"utilities/#Dimension-reduction","page":"Utilities","title":"Dimension reduction","text":"Any PeriodicGraph can be naturally reduced to an aperiodic graph by removing all offsets from the edges and either keeping (quotient_graph) or removing (truncated_graph) edges crossing from one unit cell to another.\n\nIt is also possible to reduce the dimension of a graph by removing only some selected offsets with the slice_graph function.","category":"section"},{"location":"utilities/#Arithmetics","page":"Utilities","title":"Arithmetics","text":"These utilities are internally used for dimensionality computations, but may be useful in other contexts.","category":"section"},{"location":"utilities/#Unclassified-other-utilities","page":"Utilities","title":"Unclassified other utilities","text":"These other convenience functions may be useful for the manipulation of PeriodicGraphs:","category":"section"},{"location":"utilities/#PeriodicGraphs.hash_position","page":"Utilities","title":"PeriodicGraphs.hash_position","text":"hash_position(x::PeriodicVertex{N}, n::Integer) where N\n\nGiven x, a PeriodicVertex{N}, and the number n of vertex identifiers in a graph, compute a unique positive integer hash for the given vertex.\n\nThis hash function is a bijection between the set of all the vertices of the periodic graph and the set of positive integers. Its value is an integer between 1+n*(2d-1)^N (or 1 if d == 0) and n*(2d+1)^N, where d = maximum(abs.(x.ofs)).\n\nIn particular, this means that when one unit cell B is further than another A from the origin (for the Manhattan distance), all vertices in B have a larger hash than all vertices in A.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PeriodicGraphs.reverse_hash_position","page":"Utilities","title":"PeriodicGraphs.reverse_hash_position","text":"reverse_hash_position(hash::Integer, n::Integer, ::Val{N}) where N\n\nGiven a hash obtained from hash_position(x, n) where x is a PeriodicVertex{N}, return the corresponding x.\n\nIf the offset of the returned PeriodicVertex is not needed, simply doing mod1(x, n) yields the identifier of the vertex and is faster.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PeriodicGraphs.vertex_permutation","page":"Utilities","title":"PeriodicGraphs.vertex_permutation","text":"vertex_permutation(g::PeriodicGraph, vlist)\n\nReturn the PeriodicGraph corresponding to g with its vertices identifiers permuted according to vlist. isperm(vlist) must hold and will not be checked.\n\nSee also Graphs.induced_subgraph for the more general case where vlist is not a permutation.\n\nnote: Note\nThe resulting graph is isomorphic to the initial one, only the representation has changed.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PeriodicGraphs.swap_axes!","page":"Utilities","title":"PeriodicGraphs.swap_axes!","text":"swap_axes!(g::PeriodicGraph, t)\n\nIn-place modifies graph g so that the new initial cell corresponds to the previous one with its axes swapped according to the permutation t.\n\nnote: Note\nThe resulting graph is isomorphic to the initial one, only the representation has changed.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PeriodicGraphs.offset_representatives!","page":"Utilities","title":"PeriodicGraphs.offset_representatives!","text":"offset_representatives!(g::PeriodicGraph, offsets)\n\nIn-place modifies graph g so that the i-th vertex of the new initial cell corresponds to the i-th vertex in cell offsets[i] compared to the previous initial cell.\n\nnote: Note\nThe resulting graph is isomorphic to the initial one, only the representation has changed.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PeriodicGraphs.make_supercell","page":"Utilities","title":"PeriodicGraphs.make_supercell","text":"make_supercell(g::PeriodicGraph, t)\n\nReturn a graph isomorphic to the input g whose its unit cell is a repetition of that of g, each dimension i being repeated t[i] times. It follows that the number of vertices of make_supercell(g, t) is prod(t)*nv(g)\n\nt must be an interator over positive integers.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PeriodicGraphs.quotient_graph","page":"Utilities","title":"PeriodicGraphs.quotient_graph","text":"quotient_graph(g::PeriodicGraph)\n\nExtract a simple graph from g by removing all indications of offset in the edges. This means that edges that used to cross the boundaries of the initial cell now bind the source vertex to the representative of the destination vertex that is in the initial cell.\n\nNote that these modified edges may turn into loops.\n\nSee also truncated_graph to remove all of these edges and slice_graph to keep only some of these edges.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PeriodicGraphs.truncated_graph","page":"Utilities","title":"PeriodicGraphs.truncated_graph","text":"truncated_graph(g::PeriodicGraph)\n\nExtract a simple graph from g by only keeping the edges that are strictly within the initial cell.\n\nSee also quotient_graph to keep all of these edges and slice_graph to keep only some of these edges.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PeriodicGraphs.slice_graph","page":"Utilities","title":"PeriodicGraphs.slice_graph","text":"slice_graph(g::PeriodicGraph{D}, remove::Union{SVector{N},NTuple{N}}) where {D,N}\n\nExtract a PeriodicGraph{D-N} from g by removing all edges that have an offset o such that !iszero(o[remove]) and shrinking the resulting offsets. In other words, remove the dimensions in remove.\n\nTo only remove the edges while keeping the same number of dimensions, use slice_graph(g, collect(remove))\n\nremove is assumed to be sorted and to contain unique elements.\n\nwarning: Warning\nNo verification of the previous assumption will be performed.\n\n\n\n\n\nslice_graph(g::PeriodicGraph{D}, remove::Vector{<:Integer}) where D\n\nExtract a PeriodicGraph{D} from g by removing all edges that have an offset o such that !iszero(o[remove]).\n\nContrarily to the slice_graph(g::PeriodicGraph{D}, remove::Union{SVector{N},NTuple{N}}) where {D,N} method, the dimensions along which the edges are erased are still kept here.\n\nremove is assumed to be sorted and to contain unique elements.\n\nwarning: Warning\nNo verification of the previous assumption will be performed.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PeriodicGraphs.extended_gcd","page":"Utilities","title":"PeriodicGraphs.extended_gcd","text":"extended_gcd(s)::Tuple{BigInt, Vector{BigInt}}\n\nGiven a list of integers, return a tuple (d, coefs) where d is the gcd of these integers and coefs is a list of integers such that dot(s, coefs) == d.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PeriodicGraphs.normal_basis","page":"Utilities","title":"PeriodicGraphs.normal_basis","text":"normal_basis(l::AbstractVector{<:StaticVector{N,T}}) where {N,T<:Integer}\n\nGiven a list of integer vectors of dimension N, return a tuple (mat, D) where D is the dimension of the space spanned by the input vectors, and mat is an invertible matrix whose D first columns form a basis of this spanned space, which does not depend on the exact input.\n\nIf D â‰  N, the remaining columns are set so that mat be invertible. These additional columns will only contain one coefficient equal to 1, and all others to 0. No other assumption should be made about these columns; in particular, they may depend on the input.\n\nwarning: Warning\nIf modifiable, the input list will be modified in-place during this process.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PeriodicGraphs.find_edges","page":"Utilities","title":"PeriodicGraphs.find_edges","text":"find_edges(g::PeriodicGraph, s::Int, d::Int)\n\nReturn the set of PeriodicVertex v of graph g such that there is an edge between a source vertex of identifier s and v, and the identifier of v is d.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PeriodicGraphs.coordination_sequence","page":"Utilities","title":"PeriodicGraphs.coordination_sequence","text":"coordination_sequence(g::PeriodicGraph, v::Integer, dmax)\n\nCompute the list of numbers of n-th neighbors of vertex v in graph g, for 1 â‰¤ n â‰¤ dmax.\n\n\n\n\n\n","category":"function"},{"location":"dimension/#Dimensionality","page":"Dimensionality","title":"Dimensionality","text":"A periodic graph g of type PeriodicGraph{N} has dimension N, which means that its unit cell is repeated across N independent axes. However, this number may be larger than the actual number of independent axes necessary to describe the repeating unit of the graph, which we will call the dimensionality. For example, consider an infinite set of identical 2-periodic graphs stacked across a third dimension: the resulting graph is of dimension 3, but its dimensionality is 2 (or below) because all the topological information is stored in the 2-periodic subgraph.\n\nThe connected components of g can be separated with Graphs.connected_components and sorted by dimensionality using the dimensionality function:\n\nSee also split_connected_components to split connected components in a more detailed fashion, when multiple components can share the same vertex indices:\n\nTo transpose a graph from one dimension N to another D, call the type constructor PeriodicGraph{D} directly on g::PeriodicGraph{N}. This can be useful to manipulate a graph of dimensionality D as a graph of actual dimension D, which often reduces computational costs.\n\nFor example, the following function extracts the list of 1-dimensional components from a given PeriodicGraph:\n\njulia> function extract_1D_components(g::PeriodicGraph{D}) where D\n           d = dimensionality(g)\n           components1D = get(d, 1, Vector{Int}[])\n           return [PeriodicGraph1D(g[l[1]]) for l in components1D]\n       end\nextract_1D_components (generic function with 1 method)\n\nLet's test it on the following 2-periodic graph, which has one 0D component (vertices 4 and 5), two 1D components (vertex 3 alone and vertices 6 and 7 together) and one 2D component (vertices 1 and 2):\n\njulia> g = PeriodicGraph2D(\"2   1 2 0 0  2 1 1 0  2 1 0 1\n                                3 3 1 0\n                                4 5 0 0\n                                6 7 1 0  7 6 1 0\n                           \")\nPeriodicGraph2D(7, PeriodicEdge2D[(1, 2, (-1,0)), (1, 2, (0,-1)), (1, 2, (0,0)), (3, 3, (1,0)), (4, 5, (0,0)), (6, 7, (-1,0)), (6, 7, (1,0))])\n\njulia> extract_1D_components(g)\n2-element Vector{PeriodicGraph1D}:\n PeriodicGraph1D(1, PeriodicEdge1D[(1, 1, (1,))])\n PeriodicGraph1D(2, PeriodicEdge1D[(1, 2, (-1,)), (1, 2, (1,))])\n\nThe first subgraph corresponds to g[[3]] and the second to g[[6,7]], both converted to PeriodicGraph1D.\n\nThe dimension of a graph can also be reduced with loss of information through the slice_graph function.","category":"section"},{"location":"dimension/#Graphs.connected_components","page":"Dimensionality","title":"Graphs.connected_components","text":"connected_components(g::PeriodicGraph)\n\nReturn the connected components of a periodic graph g as lists of vertex indices.\n\nnote: Note\nEven when two vertex indices a and b are in the same connected component, this does not necessarily imply that the two corresponding vertices in given unit cells are.For example, in graph PeriodicGraph(\"1  1 2 1  2 1 1\"), there are vertices of index 1 and 2 which are connected, so the only connected component is given as [1, 2]. However, PeriodicVertex(1, (0,)) and PeriodicVertex(2, (0,)) do not belong to the same connected component, as there is no path from one to the other. Similarly, PeriodicVertex(1, (0,)) and PeriodicVertex(1, (1,)) do not belong to the same connected component either.\n\nSee also dimensionality and split_connected_components.\n\n\n\n\n\n","category":"function"},{"location":"dimension/#PeriodicGraphs.dimensionality","page":"Dimensionality","title":"PeriodicGraphs.dimensionality","text":"dimensionality(g::PeriodicGraph{N}) where N\n\nDetermine the actual dimension of each connected component of g. Return a dictionary where each entry n => [(l1,m1), (l2,m2), ...] means that li is a list of vertices that form a connected component of dimension n, and that component is present mi times per unit cell.\n\nIn other words, the connected component li has a periodicity that can only be expressed in a unit cell mi times larger than the current one. See also split_connected_components.\n\nExamples\n\njulia> dimensionality(PeriodicGraph(\"2   1 1  1 0   2 2  -1 1   3 3  1 0   3 3  0 1\"))\nDict{Int64, Vector{Tuple{Vector{Int64}, Int64}}} with 2 entries:\n  2 => [([3], 1)]\n  1 => [([1], 1), ([2], 1)]\n\njulia> dimensionality(PeriodicGraph(\"1   1 1  2\"))\nDict{Int64, Vector{Tuple{Vector{Int64}, Int64}}} with 1 entry:\n  1 => [([1], 2)]\n\n\n\n\n\n","category":"function"},{"location":"dimension/#PeriodicGraphs.split_connected_components","page":"Dimensionality","title":"PeriodicGraphs.split_connected_components","text":"split_connected_components(graph::PeriodicGraph{N}) where N\n\nReturn a list of tuples (subgraph, vmaps, mat, dim) where subgraph is a connected component of the input graph. Each sublist vmap in vmaps is a distinct mapping of the vertices of the graph into those of the corresponding subgraph. The union of all the vertices in all the vmaps, repeated with the according periodicity, exactly covers all the vertices of the input graph, without repetition. dim is the dimensionality of these connected components, and mat is the transformation matrix between the input cell and the component's cell.\n\nEach sublist contains connected components that share the same vertex indices.\n\nExample\n\njulia> g = PeriodicGraph(\"2    1 1  3 0   1 1  0 1   2 3  1 0   3 2  1 0\");\n\njulia> dimensionality(g)\nDict{Int64, Vector{Tuple{Vector{Int64}, Int64}}} with 2 entries:\n  2 => [([1], 3)]\n  1 => [([2, 3], 2)]\n\njulia> splits = split_connected_components(g);\n\njulia> last.(splits) # One 2-dimensional catenation (vertex 1), one 1-dimensional (vertices 2 and 3)\n2-element Vector{Int64}:\n 2\n 1\n\njulia> subgraph, vmaps, mat, dim = last(splits);  # the 1-dimensional connected components\n\njulia> vmaps  # first sublist takes vertex 2 from the reference unit cell, second one takes vertex 3.\n2-element Vector{PeriodicGraphs.OffsetVertexIterator{2}}:\n [(2, (0,0)), (3, (-1,0))]\n [(2, (1,0)), (3, (0,0))]\n\njulia> subgraph  # the subgraph consists in only the two relevant two vertices\nPeriodicGraph2D(2, PeriodicEdge2D[(1, 2, (0,0)), (1, 2, (1,0))])\n\njulia> mat  # the new cell is twice as large as the initial one\n2Ã—2 StaticArraysCore.SMatrix{2, 2, Int64, 4} with indices SOneTo(2)Ã—SOneTo(2):\n 2  0\n 0  1\n\n\n\n\n\n","category":"function"},{"location":"dimension/#PeriodicGraphs.PeriodicGraph-Union{Tuple{PeriodicGraph{N}}, Tuple{N}, Tuple{D}, Tuple{PeriodicGraph{N}, Any}} where {D, N}","page":"Dimensionality","title":"PeriodicGraphs.PeriodicGraph","text":"PeriodicGraph{D}(graph::PeriodicGraph{N}) where {D,N}\n\nReturn a graph that has the same structural information as the input graph but embedded in D dimensions instead of N. It will fail if the dimensionality of the graph is greater than D.\n\nnote: Note\nThe behaviour is undefined if D < N and there are multiple non-identical connected components. In particular, the function is expected to fail if these components do not share the same orientation.\n\n\n\n\n\n","category":"method"},{"location":"#PeriodicGraphs.jl","page":"Home","title":"PeriodicGraphs.jl","text":"A Julia package for the manipulation of periodic graphs.","category":"section"},{"location":"#Usages","page":"Home","title":"Usages","text":"PeriodicGraphs.jl defines types and algorithms useful for the manipulation of N-periodic undirected graphs, with N known at compile-time. It extends Graphs.jl by providing the new PeriodicGraph type which implements the AbstractGraph API. It also provides an API for the manipulation of symmetries.\n\nThis package serves as support for the PeriodicGraphEmbeddings.jl library, which focuses on euclidean embeddings of periodic graphs, and for CrystalNets.jl for the manipulation and identification of crystal nets, which are 2 or 3-periodic graphs.","category":"section"},{"location":"#Package-installation","page":"Home","title":"Package installation","text":"The installation follows the usual procedure. Start by downloading and installing Julia (v1.6 or higher for PeriodicGraphs.jl). Then, either\n\nopen the Julia REPL and enter the package manager by typing ], then install PeriodicGraphs.jl by entering:\npkg> add PeriodicGraphs\nalternatively, you can do it from a shell by executing:\njulia -e 'import Pkg; Pkg.add(\"PeriodicGraphs\")\n\nTo use the package, open a REPL and enter\n\njulia> using PeriodicGraphs","category":"section"},{"location":"symmetries/#Symmetries","page":"Symmetries","title":"Symmetries","text":"PeriodicGraphs.jl comes with a general API for the manipulation of symmetries. Concrete implementations of the API can be found in PeriodicGraphEmbeddings.jl.","category":"section"},{"location":"symmetries/#Single-symmetry-operations","page":"Symmetries","title":"Single symmetry operations","text":"","category":"section"},{"location":"symmetries/#Symmetry-group","page":"Symmetries","title":"Symmetry group","text":"","category":"section"},{"location":"symmetries/#PeriodicGraphs.AbstractSymmetry","page":"Symmetries","title":"PeriodicGraphs.AbstractSymmetry","text":"abstract type AbstractSymmetry end\n\nAn abstract type representing a symmetry.\n\nInterface\n\nSubtypes T of AbstractSymmetry should implement a method to make their objects symm callable on any object upon which the symmetry can act. For example, if T represents a symmetry of a 3D embedding of a graph:\n\nif x represents a 3D point, then symm(x) should be the image of that point.\nif x represents a 3D basis of space, then symm(x) should be the image of that basis.\n\nWhen the symmetry is naturally defined on a discrete set of objects, their image should be accessible by indexing on the symmetry. With the same example as before:\n\nif x is a vertex, symm[x] is the image of x by the symmetry.\nif i is the integer identifier of vertex x, symm[i] is the identifier of symm[x].\n\n\n\n\n\n","category":"type"},{"location":"symmetries/#PeriodicGraphs.IdentitySymmetry","page":"Symmetries","title":"PeriodicGraphs.IdentitySymmetry","text":"IdentitySymmetry <: AbstractSymmetry\n\nIdentity symmetry, i.e. such that for s::IdentitySymmetry, âˆ€x, s[x] == x.\n\n\n\n\n\n","category":"type"},{"location":"symmetries/#PeriodicGraphs.SimpleSymmetry","page":"Symmetries","title":"PeriodicGraphs.SimpleSymmetry","text":"SimpleSymmetry{K,T,D} <: AbstractSymmetry\n\nSymmetry operation defined by a map of type T and an optional dict of type D accepting keys of type K.\n\n\n\n\n\n","category":"type"},{"location":"symmetries/#PeriodicGraphs.SimpleSymmetry-Union{Tuple{D}, Tuple{T}, Tuple{T, D}} where {T, D}","page":"Symmetries","title":"PeriodicGraphs.SimpleSymmetry","text":"SimpleSymmetry(map::T, dict::D) where {T,D}\n\nCreate a SimpleSymmetry{keytype(D),T,D} object symm such that symm[x] is\n\nmap[dict[x]] if x isa keytype(D).\nmap[x] otherwise, if x isa Integer.\n\n\n\n\n\n","category":"method"},{"location":"symmetries/#PeriodicGraphs.SimpleSymmetry-Tuple{Any}","page":"Symmetries","title":"PeriodicGraphs.SimpleSymmetry","text":"SimpleSymmetry(map)\n\nCreate a SimpleSymmetry object symm such that symm[x] == map[x] for all x.\n\n\n\n\n\n","category":"method"},{"location":"symmetries/#PeriodicGraphs.AbstractSymmetryGroup","page":"Symmetries","title":"PeriodicGraphs.AbstractSymmetryGroup","text":"AbstractSymmetryGroup{T<:AbstractSymmetry}\n\nAn abstract type representing the set of symmetries of a graph.\n\nInterface\n\nAny AbstractSymmetryGroup type must define methods for Base functions unique, iterate, length and one such that, for any s of type <: AbstractSymmetryGroup{T}:\n\ns(i) is a representative on the symmetry orbit of i such that all elements on the orbit share the same representative. The representative should be an integer.\nunique(s) is an iterator over such representatives.\niterating over s yields the list of symmetry operations symm, each represented as an object of type T (where T <:AbstractSymmetry is the parameter to typeof(s)). The identity symmetry should not be part of these yielded symm, except for the specific IncludingIdentity subtype of AbstractSymmetryGroup.\none(s) is the identity symmetry of type T.\n\n\n\n\n\n","category":"type"},{"location":"symmetries/#PeriodicGraphs.NoSymmetryGroup","page":"Symmetries","title":"PeriodicGraphs.NoSymmetryGroup","text":"NoSymmetryGroup <: AbstractSymmetryGroup{IdentitySymmetry}\n\nThe trivial AbstractSymmetryGroup devoid of any symmetry operation. NoSymmetryGroup(num) creates a NoSymmetryGroup over num unique representatives.\n\n\n\n\n\n","category":"type"},{"location":"symmetries/#PeriodicGraphs.IncludingIdentity","page":"Symmetries","title":"PeriodicGraphs.IncludingIdentity","text":"IncludingIdentity{S<:AbstractSymmetry,T<:AbstractSymmetryGroup{S}} <: AbstractSymmetryGroup{S}\n\nWrapper around an AbstractSymmetry that explicitly includes the identity operation.\n\n\n\n\n\n","category":"type"}]
}
